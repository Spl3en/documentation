---
title: "Writing SCORE"
---

This document presents how to write a SCORE, smart contract of ICON network.
You can understand from setting the workspace to deploying a SCORE.

Exactly speaking, SCORE is the platform for ICON's smart contract. But it is also used to represent a ICON's smart contract itself.

## Intended Audience

* Mid
* Experienced

## Purpose

You can understand how to write SCORE.

## Prerequisite

* [SCORE Overview](https://github.com/icon-project/documentation/blob/master/score/score-overview.md)
* [SCORE by Example](https://github.com/icon-project/documentation/blob/master/score/score-by-example.md)
* [T-Bears Tutorial](https://github.com/icon-project/t-bears)

## Creating Workspace

SCORE is written in Python programming language, so you can use any tools for programming for Python, as long as the required files, as described below, are included in the SCORE package. These files are all text.
* \_\_init\_\_.py: Indicating the directory as containing packages.
* _project.py_: The main module file of the SCORE to be executed at the top level and this should be specified in `package.json`.
* package.json: Providing basic information of the SCORE.

If you want to use more convenient way to create a workspace, you may use T-Bears. One of functions provided by T-Bears is to create a workspace for writing SCORE applications.  It creates some template source files for SCORE, as mentioned above, and other files for configuration of development environments. You can refer the T-Bears guide for the details.

You can use T-Bears `init` command with project name and main class name. For example:

```console
$ tbears init hello_world HelloWorld
```

You can see the generated files after running T-Bears `init` command.

```console
$ ls -lF
total 4
drwxr-xr-x  6 edward  staff   192  4  4 10:24 hello_world/

$ ls -lF hello_world/
total 16
-rw-r--r--  1 edward  staff    0  4  4 10:20 __init__.py
-rw-r--r--  1 edward  staff  420  4  4 10:20 hello_world.py
-rw-r--r--  1 edward  staff   90  4  4 10:20 package.json
drwxr-xr-x  4 edward  staff  128  4  4 10:23 tests/
```

## Structure of SCORE

SCORE is a collection of codes written in Python. There should be a main class which has member variables and methods. The main class should be specified in the `package.json` file as the value of `main_score` field, so that nodes are able to know what class should be loaded and executed at first. Actually, the main class should have at least three methods which are supposed to be invoked at loading, installing and updating SCORE respectively. In addition, the main class should have more than one external method, which are supposed to be invoked by transactions from EOA or other Smart Contracts, and may update the internal states. The main class can have member variables to store its states, and those variables should be incorporated with the state database, which will be mentioned later as VarDB, DictDB, and ArrayDB.

The following is a content of the main class which we have just generated by T-Bears `init` command.

```python
from iconservice import *

TAG = 'HelloWorld'

class HelloWorld(IconScoreBase):

    def __init__(self, db: IconScoreDatabase) -> None:
        super().__init__(db)

    def on_install(self) -> None:
        super().on_install()

    def on_update(self) -> None:
        super().on_update()

    @external(readonly=True)
    def hello(self) -> str:
        Logger.debug(f'Hello, world!', TAG)
        return "Hello"
```


## IconScoreBase

Every main class of SCORE should be inherited from `IconScoreBase`. If the main class is not derived from `IconScoreBase`, it cannot be deployed.

The main class should have at least 3 member methods, `__init__`, `on_install` and `on_update`.


### \_\_init\_\_

`__init__` is the constructor for the class.  This method gets called when memory for the class object is allocated.

Member variables can be declared here, however, declaring member variables which are not managed as states is prohibited.  In other words, all member variables which should keep values during executions of smart contract must be stored in state database.

Here's an example of declaring member variables as the state database.

```python
def __init__(self, db: IconScoreDatabase) -> None:
    # Parent’s __init__ method must be called as well
    super().__init__(db)

    self._total_supply = VarDB('total_supply', db, value_type=int)
    self._decimals = VarDB('decimals', db, value_type=int)
    self._balances = DictDB('balances', db, value_type=int)
```

### on\_install

This method is called when the smart contract is deployed for the first time, and will not be called again on contract update or deletion afterward. This is the place where you initialize the state database.

### on\_update
This method is called when the smart contract is updated.


## Implementing Methods

Users can implement methods which are supposed to be invoked by transactions.
These methods can be decorated with `@external` and `@payable`.
Additionally users can declare methods decorated with `@eventlog` which can be used to leave custom events in TxResult.

### External decorator (@external)

Methods decorated with `@external` can be called from outside the contract. These methods are registered on the external API list and users can query the API list through `icx_getScoreApi` JSON RPC call.

Any attempt to call a non-external method from outside the contract will fail.

If a method is decorated with a  `readonly` parameter, i.e., `@external(readonly=True)`, the method will have read-only access to the state database.

If a read-only external method is also decorated with `@payable`, the method call will fail.

Duplicate declaration of `@external` will raise an exception on class loading time.

Possible data types for external method parameters are Python primitive types (`int`, `str`, `bytes`, `bool`) and `Address` (newly defined type for SCORE codes).
`list`, `dict` and `None` types are not supported for method parameters.
Default values for method parameters could be set.


### Payable decorator (@payable)

Only methods with `@payable` decorator are permitted to receive incoming ICX coins.
Transferring zero ICX is acceptable if it is decorated with `@payable`.
If ICX coins (`self.msg.value`) are passed to a non-payable method, that transaction will fail.


### Eventlog decorator (@eventlog)

Methods decorated with `@eventlog` can be called within SCORE codes during the execution of a transaction to include custom event logs in its TxResult as `eventlogs`.
It is recommended to declare a method without implementation body.
Even if the method has a implementation body, it does not be executed. When declaring a method, Python type hinting must be specified.
Without the type hinting, SCORE loading will fail.

If an `indexed` parameter is set in the decorator, designated number of parameters in the order of declaration will be indexed and included in the Bloom filter.
At most 3 parameters can be indexed, and the index cannot exceed the number of parameters, otherwise an error will be raised.
Indexed parameters and non-indexed parameters are separately stored in TxResult.

Example)
```python
# Declaration
@eventlog
def FundTransfer1(self, _backer: Address, _amount: int, _isContribution: bool): pass

@eventlog(indexed=1) # The first parameter (_backer) will be indexed
def FundTransfer2(self, _backer: Address, _amount: int, _isContribution: bool): pass

# Execution
self.FundTransfer1(self.msg.sender, amount, True)
self.FundTransfer2(self.msg.sender, amount, True)
```

### fallback

`fallback` is a special method that is executed whenever the smart contract receives plain ICX coins without data.

```python
@payable
def fallback(self):
    """
    Called when anyone sends ICX to the SCORE.
    """
    if something_wrong:
        revert('something wrong')
```

If `fallback` method is not decorated with `@payable`, the ICX coin transfers to the contract will fail even for the zero ICX transfer.

`fallback` method can not be decorated with `@external` (i.e., `fallback` method is not allowed to be called explicitly by other contract or user).
An exception will be raised and the SCORE will be rejected during its deployment if `fallback` has `@external` decorator.

If you query the SCORE API list, you will receive `fallback` method only if it is decorated with `@payable` decorator.


## Storing State Data

The state of SCORE should be stored in the state database in the blockchain. The state of SCORE simply means the values of member variables in the smart contract which are declared as VarDB, DictDB and ArrayDB. The state of SCORE can be changed only by execution of transactions. All nodes execute transactions and change the state of the smart contract in their own state database independently. Since the nodes cannot always be trusted and sure to safe, the changed state should also be agreed between the  ⅔ of nodes after each execution of transactions, and this process is called consensus in blockchain.

In general, the state database is a key-value database, and can be accessed using VarDB, DictDB and ArrayDB classes.

VarDB, DictDB and ArrayDB are utility classes wrapping the state database.
A `key` can be numbers or characters, and `value_type` can be `int`, `str`, `bytes` and `Address`.
If the `key` does not exist, the wrapping classes return the *zero value* of `value_type`, which is 0 for `int`,
"" for `str`, and None for `bytes` or `Address`.

VarDB can be used to store simple key-value state, and DictDB behaves more like Python `dict`.
DictDB does not maintain order, whereas ArrayDB, which supports length and iterator, maintains order.

**VarDB(‘key’, ‘target db’, ‘return type’)**

Example) Setting a value "icon" for the key "name" on the state DB:

```python
VarDB('name', db, value_type=str).set('icon')
```

Example) Getting value by the key "name":

```python
name = VarDB('name', db, value_type=str).get()
print(name) ## 'icon'
```

**DictDB(‘key’, ‘target db’, ‘return type’, ‘dict depth (default is 1)’)**

Example 1) One-depth dict

```python
test_dict1 = DictDB('test_dict1', db, value_type=int)
test_dict1['key'] = 1 ## set
print(test_dict1['key']) ## get 1

print(test_dict1['nonexistence_key']) # prints 0 (key does not exist and value_type=int)
```

Example 2) Two-depth dict

```python
test_dict2 = DictDB('test_dict2', db, value_type=str, depth=2)
test_dict2['key1']['key2'] = 'a' ## set
print(test_dict2['key1']['key2']) ## get 'a'

print(test_dict2['key1']['nonexistent_key']) # prints "" (key does not exist and value_type=str)
```

If the depth is more than 2, `test_dictN['key']` returns new DictDB with the depth N-1.
Attempting to set a value to the wrong depth in the DictDB will raise an exception.

Example 3)
```python
test_dict3 = DictDB('test_dict3', db, value_type=int, depth=3)
test_dict3['key1']['key2']['key3'] = 1 ## ok
test_dict3['key1']['key2'] = 1 ## raise mismatch exception

test_dict2 = test_dict3['key']['key2']
test_dict2['key1'] = 1 ## ok
```

**ArrayDB(‘key’, ‘target db’, ‘return type’)**

ArrayDB supports one dimensional array only.
ArrayDB supports put, get and pop operations, i.e., the data can be accessed in stack-like fashion.  It does not support insert or delete operation (adding or removing elements in the middle of array).

```python
test_array = ArrayDB('test_array', db, value_type=int)
test_array.put(0)
test_array.put(1)
test_array.put(2)
test_array.put(3)
print(len(test_array)) ## prints 4
print(test_array.pop()) ## prints 3
test_array[0] = 0 ## ok
# test_array[100] = 1 ## error
for e in test_array: ## ok
    print(e)
print(test_array[-1]) ## ok
# print(test_array[-100]) ## error
```

#### Cautions about VarDB, DictDB and ArrayDB

The state should be stored in the persistent storage (state database), but simple variables which reside in memory are volatile and will be reset when the nodes is restarted. Thus users need to use the wrapping classes of the state database, VarDB, ListDB and DictDB, to store the state permanently. But you should use these classes in right way, otherwise you might face some unexpected results.

Example)
```python
varDB = VarDB(...)
varDB.set(100)       # right
varDB = 100          # wrong

arrayDB = ArrayDB(...)
arrayDB[0] = 100     # right
arrayDB = 100        # wrong

dictDB = DictDB(...)
dictDB['key0'] = 100 # right
dictDB = 100         # wrong
```

## Built-in Properties

These are member variables supported by `IconScoreBase`, which are supposed to be set by ICON platform to deliver some necessary information to the SCORE.  So these are read-only variables and do not allowed to be modified by the contract.

* `msg` : Holds information of the account who called the SCORE
    - `msg.sender`: Address of the account who called this method.
                  If other contact called this method, `msg.sender` points to the caller contract's address.
    - `msg.value`: Amount of ICX that the sender attempts to transfer to the SCORE.

* `tx` : Transaction information
    - `tx.origin`: The account who created the transaction.
    - `tx.index`: Transaction index.
    - `tx.hash`: Transaction hash.
    - `tx.timestamp`: Transaction creation time.
    - `tx.nonce`: (optional) an arbitrary number set by the sender.

* `icx` : An object used to transfer ICX coin
    - `icx.transfer(addr_to: Aaddress, amount: int) -> None`
       Transfers designated amount of ICX coin to `addr_to`.
       If an exception occurs during execution, the exception will be escalated to the user.
    - `icx.send(addr_to: Address, amount: int) -> bool`
       Sends designated amount of ICX coin to `addr_to`.
       Basic behavior is same as `icx.transfer`, but the raised exception will be caught inside the method.
       Returns `True` when coin transfer succeeded, `False` when it failed.

* `db` : An instance used to access state DB
* `address` : Address of the SCORE
* `owner` : Address of the account who deployed the contract
* `block_height` : Current block height
* `now` : Wrapping method of `block.timestamp`.

## Built-in Classes
### Address
Address class provides types and utilities for using the address in the smart contract.

* prefix: AddressPrefix.EOA(0) or AddressPrefix.CONTRACT(1)
* body: 20-byte address body part
* is_contract: Whether the address is SCORE
* to_bytes(self) -> bytes:R eturns data as bytes from the address object
* from_string(address: str) -> Address: A static method creates an address object from given 42-char string address
* from_data(prefix: AddressPrefix, data: bytes) -> Address: A static method creates an address object(type of prefix) using given bytes data


## Built-in Global Functions

SCORE also provides the built-in library.

### create_interface_score
**create_interface_score('score address', 'interface class') -> interface class instance**

This method returns an object, through which you have an access to the designated SCORE's external methods.

### revert
**revert(message: str) -> None**

Developer can force a revert exception.
If the exception is thrown, all the changes in the state DB in current transaction will be rolled back.

### sha3_256
**sha3_256(data: bytes) -> bytes**

Computes hash using the input data

### recover_key

TBD

### json_dumps
**json_dumps(obj: Any, \*\*kwargs) -> str**

Converts a python object obj to a JSON string

### json_loads
**json_loads(src: str, \*\*kwargs) -> str**

Parses a JSON string src and converts to a python object


## Invoking Other SCORE Methods

### InterfaceScore
InterfaceScore is an interface class used to invoke other SCORE’s method.
This interface should be used instead of legacy ‘call’ method. Usage syntax is as follows.

```python
class TokenInterface(InterfaceScore):
    @interface
    def transfer(self, addr_to: Address, value: int) -> bool: pass
```

If other SCORE has the method that has the same signature as defined here with @interface decorator,
then that method can be invoked via InterfaceScore class object.
Like @eventlog decorator, it is recommended to declare a method without implementation body.
If there is a method body, it will be simply ignored.

Example) You need to get an InterfaceScore object by using IconScoreBase’s built-in API, create_interface_score('score address', 'interface class').
Using the object, you can invoke other SCORE’s external method as if it is a local method call.

```python
#Crowdsale SCORE
...
    @payable
    def fallback(self):
        """
        Called when anyone sends funds to the SCORE.
        This SCORE regards it as a contribution.
        """
        if self._crowdsale_closed.get():
            revert('Crowdsale is closed.')

        # Accepts the contribution
        amount = self.msg.value
        self._balances[self.msg.sender] = self._balances[self.msg.sender] + amount
        self._amount_raised.set(self._amount_raised.get() + amount)
        value = int(amount / self._price.get())
        data = b'called from Crowdsale'

        # Gives tokens to the contributor as a reward
        token_score = self.create_interface_score(self._addr_token_score.get(), TokenInterface) # InterfaceScore define
        token_score.transfer(self.msg.sender, value, data) # InterfaceScore call

        if self.msg.sender not in self._joiner_list:
            self._joiner_list.put(self.msg.sender)

        self.FundTransfer(self.msg.sender, amount, True)
        Logger.debug(f'FundTransfer({self.msg.sender}, {amount}, True)', TAG)
```

## Transfer ICX

Using "icx" object and it offers 2 methods, "send" and "transfer".

* **transfer** : Transfers designated amount of icx coin to addr_to.
If exception occurs during execution, the exception will be escalated.
Returns True if coin transfer succeeds.

* **send** : Sends designated amount of icx coin to addr_to.
Basic behavior is same as transfer, the difference is that exception is caught inside the method.
Returns True when coin transfer succeeded, False when failed.

## Type Hints

Hinting types is highly recommended for the input parameters and return value. When the clients want to query the list of SCORE's API, API specification is generated based on its type hints. If type hints are not given, only method names will return.

```python
@external(readonly=True)
def func1(arg1: int, arg2: str) -> int:
    return 100
```
Possible data types for method parameters are ``int``, ``str``, ``bytes``, ``bool``, and ``Address``.
``List`` and ``Dict`` type parameters are not supported yet.
Returning types can be ``int``, ``str``, ``bytes``, ``bool``, ``Address``, ``List``, and ``Dict``.


## Exception handling

When you handle exceptions in your contract, it is recommended to use revert function rather
than using an exception inherited from IconServiceBaseException.


## Packaging


### package.json

Before deploying the SCORE, the required files should be packaged into a zip file. This file should have meta information as well as smart contract source code. The meta information file, package.json, should contain a version, main module name, and main class.

This json file describes like this.

```json
{
    "version": "0.0.1",
    "main_module": "hello_world",
    "main_score": "HelloWorld"
}
```

The SCORE platform will find main_score class in the main_module.py to load into the ICON network.

if you want to point main_module as submodule, you can specify the module name like below.
```json
{
    "version": "0.0.1",
    "main_module": "sub_module.hello_world",
    "main_score": "HelloWorld"
}
```

## Deploy

In this example for deploying a smart contract, local node emulator by TBears will be used. If you want to deploy on Main-net or Test-net, you can edit URL and KeyStore in tbears_cli_config.json.

The [Simple Token project](https://github.com/icon-project/documentation/blob/master/score/score-by-example.md) is used in this paragraph as sample.

### Deploy SampleToken on Local-Node emulated by TBears

1. Generate T-Bears cli config

	```console
	$ tbears genconf
	```

1. TBears start emulator on local environment.

	```console
	$ tbears start
	```

1. Open "tbears_cli_config.json" and edit it as belows.

	Parameters for on_install() method should be set as belows.

	* __initialSupply: 1000
	* __decimals: 18



	```json
	# tbears_cli_config.json
	{
	    "uri": "http://127.0.0.1:9000/api/v3",
	    "nid": "0x3",
	    "keyStore": null,
	    "from": "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
	    "to": "cx0000000000000000000000000000000000000000",
	    "deploy": {
		"stepLimit": "0x10000000",
		"mode": "install",
		"scoreParams": {
		      "_initialSupply": "0x3e8",
		      "_decimals": "0x12"
		    }
	    },
	    "txresult": {},
	    "transfer": {
		"stepLimit": "0xf4240"
	    }
	}
	```

1. Deploy the SampleToken

  Using `deploy` command in `tbears`, you can deploy sample_token project with configuration 'tbears_cli_config.json'.
  The `tbears` automatically makes zip file from sample_token directory.

  ```console
  $ tbears deploy sample_token -c tbears_cli_config.json
  Send deploy request successfully.
  If you want to check SCORE deployed successfully, execute txresult command
  transaction hash: 0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7
  ```

1. Get transaction result by transaction hash.

	You can check the result of deployment by querying the transaction hash.

	```console
	$ tbears txresult 0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7
	```

	The results of trasaction contain several information as seen in below. You can find the `scoreAddress`, which is the address of this deployed SCORE.

	```console
	Transaction result: {
	    "jsonrpc": "2.0",
	    "result": {
		"txHash": "0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7",
		"blockHeight": "0xbe",
		"blockHash": "0xdc85bccb32109da6cfe5bb5308121ce68a1494c499d9dd8c724a0bd7397d0729",
		"txIndex": "0x0",
		"to": "cx0000000000000000000000000000000000000000",
		"scoreAddress": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
		"stepUsed": "0x2cc8f10",
		"stepPrice": "0x0",
		"cumulativeStepUsed": "0x2cc8f10",
		"eventLogs": [],
		"logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		"status": "0x1"
	    },
	    "id": 1
	}
	```

## Call SCORE methods

### Call read-only methods to query some informations.

The SCORE methods are executed by calling JSON RPC API. So, You need to generate JSON file which contains informations about calling method and prameters.

To call a read-only functinos, the method in the JSON RPC API should be `icx_call`.

#### To query total supply of this Sample Token.

Make JSON file to call `totalSupply` in Sampletoken.

```json
# sand.json
{
  "jsonrpc": "2.0",
  "method": "icx_call",
  "params": {
    "from": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
    "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
    "dataType": "call",
    "data": {
      "method": "totalSupply"
    }
  },
  "id": 1
}
```

You can use `tbears` with command `call` and parameters `send.json`.

```console
$ tbears call send.json
```

You can get the result of calling `totalSupply` as seen below. The total supply of this Token is 0x3635c9adc5dea00000.

```console
response : {
    "jsonrpc": "2.0",
    "result": "0x3635c9adc5dea00000",
    "id": 1
}
```

#### To query balance of specific address.

Edit JSON file to call `balanceOf` on the SampleToken.

```json
# sand.json
{
  "jsonrpc": "2.0",
  "method": "icx_call",
  "params": {
    "from": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
    "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
    "dataType": "call",
    "data": {
      "method": "balanceOf",
      "params": {
        "_owner": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6"
      }
    }
  },
  "id": 1
}
```

You can use `tbears` with command `call` and parameters `send.json`.

```console
$ tbears call send.json
```

The result of calling method `balanceOf` is 0, that means the balance of address `hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6` is 0.

```console
response : {
    "jsonrpc": "2.0",
    "result": "0x0",
    "id": 1
}
```


### Call writable methods.

The method of calling writable funcgtions should be `icx_sendTransaction`.

The writable methods can change the states of the smart contract. So, the signature should be presented in the requests.

The `to` is address of the smart contract, which has the writable methods.

The following example request is transfering 1 token to `hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6` from `hxe7af5fcfd8dfc67530a01a0e403882687528dfcb`.

```json
# send.json
{
  "jsonrpc": "2.0",
  "method": "icx_sendTransaction",
  "params": {
    "version": "0x3",
    "from": "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
    "value": "0x0",
    "stepLimit": "0x3000000",
    "timestamp": "0x573117f1d6568",
    "nid": "0x3",
    "nonce": "0x1",
    "to": "cx658e956f66a1449212132a750d716cec418e6193",
    "signature": "",
    "dataType": "call",
    "data": {
      "method": "transfer",
      "params": {
        "_to": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
        "_value": "0xDE0B6B3A7640000"
      }
    }
  },
  "id": 1
}
```

The request of calling writable methods with `tbears` is same as the one of calling read-only methods.

```console
$ tbears call send.json
```

After calling a methods, that is, sending a trasaction with the JSON request, you can get the following response containing the transaction hash as receipt of trasaction.

```console
response : {
    "jsonrpc": "2.0",
    "result": "0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5",
    "id": 1
}
```

The transaction hash which is in the response of calling method, doesn't mean the success or fail of the transactions. It is just a receipt that the submitted transaction is executed. You can find the result of calling method by checking `status`, `eventLog` or `logBloom` of transaction result.

```console
$ tbears txresult 0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5
Transaction result: {
    "jsonrpc": "2.0",
    "result": {
        "txHash": "0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5",
        "blockHeight": "0x4c",
        "blockHash": "0x7f53737f9ead2a04afe72d90bef072d49fa74c1f37b4029801e787aa15d37895",
        "txIndex": "0x0",
        "to": "cx658e956f66a1449212132a750d716cec418e6193",
        "stepUsed": "0xfdb2e",
        "stepPrice": "0x0",
        "cumulativeStepUsed": "0xfdb2e",
        "eventLogs": [
            {
                "scoreAddress": "cx658e956f66a1449212132a750d716cec418e6193",
                "indexed": [
                    "Transfer(Address,Address,int,bytes)",
                    "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
                    "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
                    "0xde0b6b3a7640000"
                ],
                "data": [
                    "0x4e6f6e65"
                ]
            }
        ],
        "logsBloom": "0x00000000000000100000002000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000100000040000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000100000002000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000080000000000000000000000000000000000000000",
        "status": "0x1"
    },
    "id": 1
}
```


## Limitations
The maximum limit of the total count of call, interface call and ICX transfer/send is 1024 in one transaction.
The limitation of stack size increment by calling external SCORE is 64 in one transaction.
Declaring member variables which not managed by states is prohibited.

## API reference
https://icon-project.github.io/score-guide/api-references.html


## Summary

## Tips or FAQs

## References


