---
title: "Writing SCORE"
---

## Overview

This document presents how to write a SCORE, smart contract of ICON network. 
You can understand from setting the workspace to deploying a SCORE.

Exactly speaking, SCORE is the platform for ICON's smart contract. But it is also used to represent a ICON's smart contract itself.

## Intended Audience

* Mid  
* Experienced

## Purpose 

You can understand how to write SCORE

## Prerequisite 

* [score-overview](https://github.com/icon-project/documentation/blob/master/score/score-overview.md)
* [score-by-example](https://github.com/icon-project/documentation/blob/master/score/score-by-example.md)
* [t-bears-tutorial](https://github.com/icon-project/t-bears)

## Creating Workspace

SCORE is written in Python programming language, so you can use any tools for programming for Python, as long as the required files, as described below,  are included in the SCORE package. These files are all text.
* \_\_init\_\_.py: source codes written in Python to initialize a SCORE.
* project.py: source codes of a SCORE, written in Python. The file name is written in package.json.
* package.json: configurations of a SCORE.

If you want to use more convenient way to create a workspace, you may use TBears. One of functions provided by TBears is to create a workspace for writing SCORE applications.  It creates some template source files for SCORE, as mentioned above,  and other files for configuration of development environments. You can refer the TBears guide for the details.

You can use “init” command with project name and main class name, as you see in below.

```console
$ tbears init hello_world HelloWorld
```

You can see the generated files after running TBears init command.

```console
$ ls -lF
total 24
drwxr-xr-x  6 edward  staff   192  4  4 10:24 hello_world/
-rw-r--r--  1 edward  staff   675  4  4 10:20 keystore_test1
-rw-r--r--  1 edward  staff   386  4  4 10:20 tbears_cli_config.json
-rw-r--r--  1 edward  staff  1212  4  4 10:20 tbears_server_config.json
$ ls -lF hello_world/
total 16
-rw-r--r--  1 edward  staff    0  4  4 10:20 __init__.py
-rw-r--r--  1 edward  staff  420  4  4 10:20 hello_world.py
-rw-r--r--  1 edward  staff   90  4  4 10:20 package.json
drwxr-xr-x  4 edward  staff  128  4  4 10:23 tests/
```

## Structure of SCORE

SCORE is a software program written in Python. There should be main class which has member variables and methods. Main class is described in configuration file “package.json”, so nodes are able to know what codes should be executed at first. Actually, this main class should have at least three methods which are supposed to be invoked at loading, installing, and updating SCORE respectively. In addition, main class has more than one external method, which is supposed to be invoked by transactions from EOA or other Smart Contracts, and may update the internal state. Main class also has variables to store state, and all variables should be stored in state database, which will mentioned below as VarDB, DictDB, and ArrayDB. 

Following is example of main class which we have just generated by TBears’ init command.

```python
from iconservice import *
  
TAG = 'HelloWorld'

class HelloWorld(IconScoreBase):

    def __init__(self, db: IconScoreDatabase) -> None:
        super().__init__(db)

    def on_install(self) -> None:
        super().on_install()

    def on_update(self) -> None:
        super().on_update()

    @external(readonly=True)
    def hello(self) -> str:
        Logger.debug(f'Hello, world!', TAG)
        return "Hello"
```


## IconScoreBase

SCORE’s main class should be inherited from IconScoreBase. If the SCORE’s main class is not derived from IconScoreBase, it can’t be deployed.

IconScoreBase declares at least 3 member functions, \_\_init\_\_(), on_install(), and on_update().


### \_\_init\_\_ 

This is a init function presented by Python originally. This function is called when the SCORE is loaded at each nodes.

Member variables can be declared here, however, declaring member variables which not managed by states is prohibited. In other words, all member variables which should keep the values during executions of smart contract should be stored in state database.

Followings are examples of using member variables as storing state.

```python
def __init__(self, db: IconScoreDatabase) -> None:
    # Also, parent’s init function must be called as follows.
    super().__init__(db)

    self._total_supply = VarDB(self._TOTAL_SUPPLY, db, value_type=int)
    self._decimals = VarDB(self._DECIMALS, db, value_type=int)
    self._balances = DictDB(self._BALANCES, db, value_type=int)

```

### on_install

This function is called when the Smart Contract is deployed for the first time, and will not be called again on contract update or deletion afterward. This is the place where you initialize the state DB.

### on_update
This function is called when the Smart Contract is updated.



## Defining Functions

You can implement functions which are supposed to be invoked by trasactions. 
These functions are methods of main class, and decorated with external, payable, and eventlog.

### External decorator (@external)

Functions decorated with @external can be called from outside the contract. These functions are registered on the exportable API list.

Any attempt to call a non-external function from outside the contract will fail.

If a function is decorated with 'readonly' parameters, i.e., @external(readonly=True), the function will have read-only access to the state database. This is similar to view keyword in Solidity.

If the read-only external function is also decorated with @payable, the function call will fail. 

Duplicate declaration of @external will raise IconScoreException on import time.


### Payable decorator (@payable)  
Only functions with @payable decorator are permitted to receive incoming ICX coins.  
Transferring 0 icx is acceptable.  
If ICX coins (msg.value) are passed to a non-payable function, that transaction will fail.


### Eventlog decorator (@eventlog)  
Functions with @eventlog decorator will include logs in its TxResult as ‘eventlogs’.  
It is recommended to declare a function without implementation body.  
Even if the function has a body, it does not be executed. When declaring a function, type hinting is a must.  
Without type hinting, transaction will fail.  
The default value for the parameter can be set.

If indexed parameter is set in the decorator, designated number of parameters in the order of declaration will be indexed and included in the Bloom filter.  
At most 3 parameters can be indexed, And index can’t exceed the number of parameters(will raise an error).  
Indexed parameters and non-indexed parameters are separately stored in TxResult.

Example)
```python
# Declaration
@eventlog
def FundTransfer1(self, _backer: Address, _amount: int, _isContribution: bool): pass

@eventlog(indexed=1) # The first param (backer) will be indexed
def FundTransfer2(self, _backer: Address, _amount: int, _isContribution: bool): pass

# Execution
self.FundTransfer1(self.msg.sender, amount, True)
self.FundTransfer2(self.msg.sender, amount, True)
```

Possible data types for function parameters are primitive types (int, str, bytes, bool, Address). Array, Dictionary and None type parameter is not supported.

### fallback
This fallback function is executed whenever the smart contract receives plain ICX coins without data. 

```python
    @payable
    def fallback(self):
        """
        Called when anyone sends ICX to the SCORE.
        """
        if something_wrong:
            revert('something wrong.')
```

If the fallback function is not decorated with @payable, the ICX coin transfers to the contract will fail.

This fallback function can not be decorated with @external. (i.e., fallback function is not allowed to be called by external contract or user.)  
If you query a SCORE api info, you can find only decorated payable fallback.

Even if you transfer zero ICX to this SCORE, it is also not allowed to be called.


## Storing State Data

The state of SCORE should be stored in the state database in the blockchain. The state means the values of variables in the smart contract and blockchain. This state of smart contract can be changed only by execution of transactions. Since all nodes execute transactions and change the state of the smart contract in its own nodes independently. Since the nodes of blockchains can’t always be trusted and can’t be sure to safe, the state should also be agreed with all ⅔ nodes after each execution of transactions, that is called consensus in blockchain.  So the values of variables should be stored in the database in blockchain for consensus. If the variables are not stored in the state database, it may not be confirmed that all nodes have the same state.

In general, state database is key-value database, and can be accessed using VarDB, DictDB, and ArrayDB classes.

VarDB, DictDB, ArrayDB are utility classes wrapping the state DB.  
A``key`` can be a number or characters, and ``value_type`` can be ``int``, ``str``, ``Address``, and ``bytes``.  
If the ``key`` does not exist, these classes return 0 when ``value_type`` is ``int``, return ""
when ``str``, return ``None`` when the ``value_type`` is ``Address`` or ``bytes``.  

VarDB can be used to store simple key-value state, and DictDB behaves more like python dict.  
DictDB does not maintain order, whereas ArrayDB, which supports length and iterator, maintains order.


**VarDB(‘key’, ‘target db’, ‘return type’)**

Example) Setting theloop for the key name on the state DB:

```python
VarDB('name', db, value_type=str).set('theloop')
```

Example) Getting value by the key name:

```python
name = VarDB('name', db, value_type=str).get()
print(name) ## 'theloop'
```

**DictDB(‘key’, ‘target db’, ‘return type’, ‘dict depth (default is 1)’)**

Example 1) One-depth dict (test_dict1[‘key’]):

```python
test_dict1 = DictDB('test_dict1', db, value_type=int)
test_dict1['key'] = 1 ## set
print(test_dict1['key']) ## get 1

print(test_dict1['nonexistence_key']) # prints 0 (key does not exist and value_type=int)
```

Example 2) Two-depth dict (test_dict2[‘key1’][‘key2’]):

```python
test_dict2 = DictDB('test_dict2', db, value_type=str, depth=2)
test_dict2['key1']['key2'] = 'a' ## set
print(test_dict2['key1']['key2']) ## get 'a'

print(test_dict2['key1']['nonexistent_key']) # prints "" (key does not exist and value_type=str)
```

If the depth is more than 2, dict[key] returns new DictDB.  
Attempting to set a value to the wrong depth in the DictDB will raise an exception.

Example 3)
```python
test_dict3 = DictDB('test_dict3', db, value_type=int, depth=3)
test_dict3['key1']['key2']['key3'] = 1 ## ok
test_dict3['key1']['key2'] = 1 ## raise mismatch exception

test_dict2 = test_dict3['key']['key2']
test_dict2['key1'] = 1 ## ok
```

**ArrayDB(‘key’, ‘target db’, ‘return type’)**  

ArrayDB supports one dimensional array only.  
ArrayDB supports put, get, and pop. It is not supported to insert (adding elements in the middle of array) into the ArrayDB.

```python
test_array = ArrayDB('test_array', db, value_type=int)
test_array.put(0)
test_array.put(1)
test_array.put(2)
test_array.put(3)
print(len(test_array)) ## prints 4
print(test_array.pop()) ## prints 3
test_array[0] = 0 ## ok
# test_array[100] = 1 ## error
for e in test_array: ## ok
    print(e)
print(test_array[-1]) ## ok
# print(test_array[-100]) ## error
```

#### Warning Case About VarDB, DictDB, ArrayDB

The variables should be stored in the block (state database), because the variables only in memory is volatile and reset when the nodes is restarted. You can use the wrapping method of database, VarDB, ListDB, and DictDB, to store the variables. But you should use these methods in right way, or you face some unexpected results.

Example)  
```python
varDB = VarDB(...)  
varDB.set(100) 		# right  
varDB = 100 		# wrong

arrayDB = ArrayDB(...)  
arrayDB[0] = 100 	# right  
arrayDB = 100		# wrong

dictDB = DictDB(...)
dictDB['key0'] = 100 	# right
dictDB = 100 		# wrong
```

## Built-in Properties

These are member variables supported by IconScoreBase, Which are supposed to be set by ICON platform to pass some information to this smart contract. So, these are read-only variables and do not allowed to modified by smart contract.

* msg : Holds information of the account who called the SCORE
	- msg.sender : Address of the account who called this function. 
			If other contact called this function, msg.sender points to the caller contract's address.
	- msg.value : Amount of icx that the sender attempts to transfer to the current SCORE.

* tx : Transaction information
	- tx.origin : The account who created the transaction.
	- tx.index : Transaction index.
	- tx.hash : Transaction hash.
	- tx.timestamp : Transaction creation time.
	- tx.nonce : (optional) random value.

* icx : An object used to transfer icx coin
	- icx.transfer(addr_to(address), amount(integer)) -> bool
		
		Transfers designated amount of icx coin to addr_to.
		If exception occurs during execution, the exception will be escalated.
		Returns True if coin transfer succeeds.

	- icx.send(addr_to(address), amount(integer)) -> bool
		
		Sends designated amount of icx coin to addr_to.
		Basic behavior is same as transfer, the difference is that exception is caught inside the function.	
		Returns True when coin transfer succeeded, False when failed.

* db : db instance used to access state DB
* address : SCORE address
* owner : Address of the account who deployed the contract
* block_height : Current block height
* now : Wrapping function of block.timestamp.

## Built-in Classes
### Address
Address class provides types and utilities for using the address in the smart contract.

* prefix: AddressPrefix.EOA(0) or AddressPrefix.CONTRACT(1)
* body: 20-byte address body part
* is_contract: Whether the address is SCORE
* to_bytes(self) -> bytes:R eturns data as bytes from the address object
* from_string(address: str) -> Address: A static method creates an address object from given 42-char string address
* from_data(prefix: AddressPrefix, data: bytes) -> Address: A static method creates an address object(type of prefix) using given bytes data


## Built-in Global Functions

SCORE also provides the built-in library.

### create_interface_score
**create_interface_score('score address', 'interface class') -> interface class instance**

This function returns an object, through which you have an access to the designated SCORE's external functions.

### revert
**revert(message: str) -> None**

Developer can force a revert exception.
If the exception is thrown, all the changes in the state DB in current transaction will be rolled back.

### sha3_256
**sha3_256(data: bytes) -> bytes**

Computes hash using the input data

### recover_key

TBD

### json_dumps
**json_dumps(obj: Any, \*\*kwargs) -> str**

Converts a python object obj to a JSON string

### json_loads
**json_loads(src: str, \*\*kwargs) -> str**

Parses a JSON string src and converts to a python object


## Invoking Other SCORE Functions

### InterfaceScore
InterfaceScore is an interface class used to invoke other SCORE’s function.  
This interface should be used instead of legacy ‘call’ function. Usage syntax is as follows.

```python
class TokenInterface(InterfaceScore):
    @interface
    def transfer(self, addr_to: Address, value: int) -> bool: pass
```

If other SCORE has the function that has the same signature as defined here with @interface decorator, 
then that function can be invoked via InterfaceScore class object.  
Like @eventlog decorator, it is recommended to declare a function without implementation body.  
If there is a function body, it will be simply ignored.

Example) You need to get an InterfaceScore object by using IconScoreBase’s built-in function create_interface_score('score address', 'interface class').  
Using the object, you can invoke other SCORE’s external function as if it is a local function call.

```python
#Crowdsale SCORE
...
    @payable
    def fallback(self):
        """
        Called when anyone sends funds to the SCORE.
        This SCORE regards it as a contribution.
        """
        if self._crowdsale_closed.get():
            revert('Crowdsale is closed.')

        # Accepts the contribution
        amount = self.msg.value
        self._balances[self.msg.sender] = self._balances[self.msg.sender] + amount
        self._amount_raised.set(self._amount_raised.get() + amount)
        value = int(amount / self._price.get())
        data = b'called from Crowdsale'

        # Gives tokens to the contributor as a reward
        token_score = self.create_interface_score(self._addr_token_score.get(), TokenInterface) # InterfaceScore define
        token_score.transfer(self.msg.sender, value, data) # InterfaceScore call

        if self.msg.sender not in self._joiner_list:
            self._joiner_list.put(self.msg.sender)

        self.FundTransfer(self.msg.sender, amount, True)
        Logger.debug(f'FundTransfer({self.msg.sender}, {amount}, True)', TAG)
```

## Transfer ICX

Using "icx" object and it offers 2 functions "send", "transfer"

* **transfer** : Transfers designated amount of icx coin to addr_to.  
If exception occurs during execution, the exception will be escalated.  
Returns True if coin transfer succeeds.

* **send** : Sends designated amount of icx coin to addr_to.  
Basic behavior is same as transfer, the difference is that exception is caught inside the function.  
Returns True when coin transfer succeeded, False when failed.

## Type Hints

Hinting types is highly recommended for the input parameters and return value. When the clients want to query the list of SCORE's API, API specification is generated based on its type hints. If type hints are not given, only function names will return.

```python
@external(readonly=True)
def func1(arg1: int, arg2: str) -> int:
    return 100
```
Possible data types for function parameters are ``int``, ``str``, ``bytes``, ``bool``, and ``Address``.
``List`` and ``Dict`` type parameters are not supported yet.
Returning types can be ``int``, ``str``, ``bytes``, ``bool``, ``Address``, ``List``, and ``Dict``.


## Exception handling

When you handle exceptions in your contract, it is recommended to use revert function rather 
than using an exception inherited from IconServiceBaseException.


## Packaging


### package.json

Before deploying the SCORE, the required files should be packaged into a zip file. This file should have meta information as well as smart contract source code. The meta information file, package.json, should contain a version, main module name, and main class. 

This json file describes like this.

```json
{
    "version": "0.0.1",
    "main_module": "hello_world",
    "main_score": "HelloWorld"
}
```

The SCORE platform will find main_score class in the main_module.py to load into the ICON network.

if you want to point main_module as submodule, you can specify the module name like below.
```json
{
    "version": "0.0.1",
    "main_module": "sub_module.hello_world",
    "main_score": "HelloWorld"
}
```

## Deploy

In this example for deploying a smart contract, local node emulator by TBears will be used. If you want to deploy on Main-net or Test-net, you can edit URL and KeyStore in tbears_cli_config.json.

The [Simple Token project](https://github.com/icon-project/documentation/blob/master/score/score-by-example.md) is used in this paragraph as sample.

### Deploy SampleToken on Local-Node emulated by TBears

1. Generate T-Bears cli config

	```console
	$ tbears genconf
	```

1. TBears start emulator on local environment.

	```console
	$ tbears start
	```

1. Open "tbears_cli_config.json" and edit it as belows.

	Parameters for on_install() function should be set as belows.

	* __initialSupply: 1000  
	* __decimals: 18  

	

	```json
	# tbears_cli_config.json
	{
	    "uri": "http://127.0.0.1:9000/api/v3",
	    "nid": "0x3",
	    "keyStore": null,
	    "from": "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
	    "to": "cx0000000000000000000000000000000000000000",
	    "deploy": {
		"stepLimit": "0x10000000",
		"mode": "install",
		"scoreParams": {
		      "_initialSupply": "0x3e8",
		      "_decimals": "0x12"
		    }
	    },
	    "txresult": {},
	    "transfer": {
		"stepLimit": "0xf4240"
	    }
	}
	```

1. Deploy the SampleToken
	
	Using `deploy` command in `tbears`, you can deploy sample_token project with configuration 'tbears_cli_config.json'.
	The `tbears` automatically makes zip file from sample_token directory.

	```console
	$ tbears deploy sample_token -c tbears_cli_config.json
	Send deploy request successfully.
	If you want to check SCORE deployed successfully, execute txresult command
	transaction hash: 0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7
	```
	

1. Get transaction result by transaction hash.

	You can check the result of deployment by querying the transaction hash.

	```console
	$ tbears txresult 0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7
	```

	The results of trasaction contain several information as seen in below. You can find the `scoreAddress`, which is the address of this deployed SCORE.
	
	```console
	Transaction result: {
	    "jsonrpc": "2.0",
	    "result": {
		"txHash": "0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7",
		"blockHeight": "0xbe",
		"blockHash": "0xdc85bccb32109da6cfe5bb5308121ce68a1494c499d9dd8c724a0bd7397d0729",
		"txIndex": "0x0",
		"to": "cx0000000000000000000000000000000000000000",
		"scoreAddress": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
		"stepUsed": "0x2cc8f10",
		"stepPrice": "0x0",
		"cumulativeStepUsed": "0x2cc8f10",
		"eventLogs": [],
		"logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		"status": "0x1"
	    },
	    "id": 1
	}
	```

## Call a SCORE functions

### Call a read-only functions to query some informations.

The SCORE functions are executed by calling JSON RPC API. So, You need to generate JSON file which contains informations about calling method and prameters.

To call a read-only functinos, the method in the JSON RPC API should be `icx_call`.

#### To query total supply of this Sample Token.

Make JSON file to call `totalSupply` in Sampletoken.

```json
# sand.json
{
  "jsonrpc": "2.0",
  "method": "icx_call",
  "params": {
    "from": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
    "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
    "dataType": "call",
    "data": {
      "method": "totalSupply"
    }
  },
  "id": 1
}
```

You can use `tbears` with command `call` and parameters `send.json`.

```console
$ tbears call send.json
```

You can get the result of calling `totalSupply` as seen below. The total supply of this Token is 0x3635c9adc5dea00000.

```console
response : {
    "jsonrpc": "2.0",
    "result": "0x3635c9adc5dea00000",
    "id": 1
}
```

#### To query balance of specific address.

Edit JSON file to call `balanceOf` on the SampleToken.

```json
# sand.json
{
  "jsonrpc": "2.0",
  "method": "icx_call",
  "params": {
    "from": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
    "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
    "dataType": "call",
    "data": {
      "method": "balanceOf",
      "params": {
        "_owner": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6"
      }
    }
  },
  "id": 1
}
```

You can use `tbears` with command `call` and parameters `send.json`.

```console
$ tbears call send.json
```

The result of calling method `balanceOf` is 0, that means the balance of address `hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6` is 0.

```console
response : {
    "jsonrpc": "2.0",
    "result": "0x0",
    "id": 1
}
```


### Call a writable functions.

The method of calling writable funcgtions should be `icx_sendTransaction`. 

The writable functions can change the states of the smart contract. So, the signature should be presented in the requests.

The `to` is address of the smart contract, which has the writable functions.

The following example request is transfering 1 token to `hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6` from `hxe7af5fcfd8dfc67530a01a0e403882687528dfcb`.

```json
# send.json
{
  "jsonrpc": "2.0",
  "method": "icx_sendTransaction",
  "params": {
    "version": "0x3",
    "from": "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
    "value": "0x0",
    "stepLimit": "0x3000000",
    "timestamp": "0x573117f1d6568",
    "nid": "0x3",
    "nonce": "0x1",
    "to": "cx658e956f66a1449212132a750d716cec418e6193",
    "signature": "",
    "dataType": "call",
    "data": {
      "method": "transfer",
      "params": {
        "_to": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
        "_value": "0xDE0B6B3A7640000"
      }
    }
  },
  "id": 1
}
```

The request of calling writable functions with `tbears` is same as the one of calling read-only functions.

```console
$ tbears call send.json
```

After calling a function, that is, sending a trasaction with the JSON request, you can get the following response containing the transaction hash as receipt of trasaction.

```console
response : {
    "jsonrpc": "2.0",
    "result": "0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5",
    "id": 1
}
```

The transaction hash which is in the response of calling function, doesn't mean the success or fail of the transactions. It is just a receipt that the submitted transaction is executed. You can find the result of calling functions by checking `status`, `eventLog` or `logBloom` of transaction result.

```console
$ tbears txresult 0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5
Transaction result: {
    "jsonrpc": "2.0",
    "result": {
        "txHash": "0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5",
        "blockHeight": "0x4c",
        "blockHash": "0x7f53737f9ead2a04afe72d90bef072d49fa74c1f37b4029801e787aa15d37895",
        "txIndex": "0x0",
        "to": "cx658e956f66a1449212132a750d716cec418e6193",
        "stepUsed": "0xfdb2e",
        "stepPrice": "0x0",
        "cumulativeStepUsed": "0xfdb2e",
        "eventLogs": [
            {
                "scoreAddress": "cx658e956f66a1449212132a750d716cec418e6193",
                "indexed": [
                    "Transfer(Address,Address,int,bytes)",
                    "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
                    "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
                    "0xde0b6b3a7640000"
                ],
                "data": [
                    "0x4e6f6e65"
                ]
            }
        ],
        "logsBloom": "0x00000000000000100000002000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000100000040000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000100000002000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000080000000000000000000000000000000000000000",
        "status": "0x1"
    },
    "id": 1
}
```


## Limitations
The maximum limit of the total count of call, interface call and ICX transfer/send is 1024 in one transaction.  
The limitation of stack size increment by calling external SCORE is 64 in one transaction.  
Declaring member variables which not managed by states is prohibited.  

## API reference
https://icon-project.github.io/score-guide/api-references.html


## Summary

## Tips or FAQs

## References


